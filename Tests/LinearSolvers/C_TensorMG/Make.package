#
# amrlib sources
#
AMR_C_SOURCES = BCRec.cpp 

AMR_C_HEADERS = BCRec.H BC_Types.H

CEXE_sources += $(AMR_C_SOURCES)
CEXE_headers += $(AMR_H_HEADERS)

#
# bndrylib sources
#
BNDRYLIB_BASE=EXE
C$(BNDRYLIB_BASE)_sources += FabSet.cpp BndryRegister.cpp \
			     Geometry.cpp CoordSys.cpp RealBox.cpp
C$(BNDRYLIB_BASE)_headers += FabSet.H BndryRegister.H \
			     Geometry.H CoordSys.H RealBox.H

F$(BNDRYLIB_BASE)_headers += COORDSYS_F.H
F$(BNDRYLIB_BASE)_sources += COORDSYS_$(DIM)D.F
#
# boxlib sources
#
BOXLIB_BASE=EXE
 
C$(BOXLIB_BASE)_sources += BoxLib.cpp Tracer.cpp RunStats.cpp
C$(BOXLIB_BASE)_headers += BoxLib.H BLVERSION.H Tracer.H RunStats.H

C$(BOXLIB_BASE)_sources += ParmParse.cpp Utility.cpp aString.cpp
C$(BOXLIB_BASE)_headers += ParmParse.H Utility.H Assert.H aString.H

C$(BOXLIB_BASE)_headers += ArrayLim.H REAL.H Boolean.H SPACE.H SPACE_F.H
C$(BOXLIB_BASE)_headers += CONSTANTS.H UseCount.H

C$(BOXLIB_BASE)_sources += DistributionMapping.cpp ParallelDescriptor.cpp
C$(BOXLIB_BASE)_headers += DistributionMapping.H ParallelDescriptor.H

C${BOXLIB_BASE}_sources += FabConv.cpp FPC.cpp BoxAssoc.cpp FArrayBox.cpp
C${BOXLIB_BASE}_headers += FabConv.H FPC.H BoxAssoc.H FArrayBox.H

C$(BOXLIB_BASE)_sources += Box.cpp IntVect.cpp IndexType.cpp Orientation.cpp
C$(BOXLIB_BASE)_headers += Box.H IntVect.H IndexType.H Orientation.H

C$(BOXLIB_BASE)_sources += BoxList.cpp BoxArray.cpp BoxDomain.cpp MultiFab.cpp
C$(BOXLIB_BASE)_headers += BoxList.H BoxArray.H BoxDomain.H Looping.H MultiFab.H

C$(BOXLIB_BASE)_sources += VisMF.cpp BArena.cpp CArena.cpp
C$(BOXLIB_BASE)_headers += VisMF.H Arena.H BArena.H CArena.H

T_sources += Array.cpp PArray.cpp List.cpp Pointers.cpp Tuple.cpp
T_headers += Array.H PArray.H List.H Pointers.H Tuple.H Misc.H

T_sources += FabArray.cpp
T_headers += BaseFab.H FabArray.H
#
# multigrid sources
#
MGLIB_BASE=EXE
C$(MGLIB_BASE)_headers += BndryData.H Mask.H
C$(MGLIB_BASE)_sources += BndryData.cpp Mask.cpp
F$(MGLIB_BASE)_headers += CG_F.H MG_F.H
F$(MGLIB_BASE)_sources += CG_$(DIM)D.F LO_UTIL.F MG_$(DIM)D.F
#
# tensorMG sources
#
MGLIB_BASE=EXE
C$(MGLIB_BASE)_headers += DivVis.H MCCGSolver.H MCInterpBndryData.H MCLinOp.H \
                          MCMultiGrid.H

C$(MGLIB_BASE)_sources += DivVis.cpp MCCGSolver.cpp MCInterpBndryData.cpp MCLinOp.cpp \
                          MCMultiGrid.cpp

F$(MGLIB_BASE)_headers += DivVis_F.H MCINTERPBNDRYDATA_F.H

F$(MGLIB_BASE)_sources += MCINTERPBNDRYDATA_$(DIM)D.F

ifeq ($(DIM),2)
F$(MGLIB_BASE)_sources += DV_2D.F
else
F$(MGLIB_BASE)_sources += DV_3D1.F DV_3D2.F DV_3D3.F DV_3D4.F
endif

#
# tensorMG test sources
#
CEXE_sources += TestMCViscBndry.cpp testVI.cpp WritePlotFile.cpp
CEXE_headers += TestMCViscBndry.H WritePlotfile.H

FEXE_sources += MCLO_$(DIM)D.F main_$(DIM)D.F
FEXE_headers += main_F.H

#
# BSP stuff
#
ifeq ($(USE_BSP),TRUE)
CEXE_sources += preload.cpp
endif

