We now enhance our heat equation example from the previous section.
Below is an outline of how we will proceed.  Each of these sections contains an 
accompanying tutorial code that builds upon the previous example.
\begin{itemize}

\item In Section \ref{Sec:Boundary Conditions} we develop the capability to handle
other (non-periodic) boundary condition types.

\item In Section \ref{Sec:Refinement} we develop the capability to have multiple
levels of refinement using a fixed, multilevel grid structure.

\item In Section \ref{Sec:AMR} we develop the capability to adaptively change the
multilevel grid structure.

\item In Section \ref{Sec:Linear Solvers} we develop the capability to solve the
equation implicitly, using the linear solver libraries.

\end{itemize}

\section{Boundary Conditions}\label{Sec:Boundary Conditions}
In order to understand how to implement boundary conditions, we shall 
first describe the general principles behind working with boundary conditions.
The {\tt BoxLib/Tutorials/HeatEquation\_EX2\_F/} tutorial continues our heat
equation example, but now with some non-periodic boundary condition support.  The boundary
condition modules in {\tt BoxLib/Src/F\_BaseLib/define\_bc\_tower.f90} and {\tt multifab\_physbc.f90} 
can be used as a springboard for developing your own customized boundary conditions.

\subsection{General Principles}
The basic idea is that every grid has knowledge of the
boundary condition type at the low and high side edge in each direction.
The ``physical'' boundary condition types supported by default are {\tt INLET}, {\tt OUTLET},
{\tt SYMMETRY}, {\tt SLIP\_WALL}, {\tt NO\_SLIP\_WALL}, and {\tt PERIODIC}.
There is also an {\tt INTERIOR} boundary condition type, which 
will be explained below.  We use an integer mapping that is 
contained in {\tt BoxLib/Src/F\_BaseLib/bc.f90}:
\begin{lstlisting}[backgroundcolor=\color{light-green}]
integer, parameter, public :: PERIODIC     = -1
integer, parameter, public :: INTERIOR     =  0

integer, parameter, public :: INLET        = 11
integer, parameter, public :: OUTLET       = 12
integer, parameter, public :: SYMMETRY     = 13
integer, parameter, public ::    SLIP_WALL = 14
integer, parameter, public :: NO_SLIP_WALL = 15
\end{lstlisting}

{\bf Examples:}
\begin{itemize}
\item Consider grid 1 in Figure \ref{fig:bc_example1}.  The
low-x boundary condition is {\tt INLET}, and the high-y boundary condition is
{\tt NO\_SLIP\_WALL}.  The high-x and low-y boundary conditions are {\tt INTERIOR}, which
means that the ghost cells share the same physical space as cells in the valid region of 
another grid.  Note that for grids 6, 7, 10, and 11, the boundary condition type for
every side is {\tt INTERIOR}.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{figure}[tb]
\centering
\includegraphics[width=4in]{./F_AdvancedTopics/bc_example1}
\caption{\label{fig:bc_example1}Two-dimensional example with 16 - 4$^2$grids with
{\tt INLET}, {\tt OUTLET}, and {\tt NO\_SLIP\_WALL} boundary conditions.
The numbers refer to the grid number.}
\end{figure}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\item Figure \ref{fig:bc_example2} demonstrates a problem with periodicity in the x-direction.
In this case, the low-x boundary condition for grid 1 is {\tt PERIODIC}.  Note there are some
similarities between {\tt PERIODIC} and {\tt INTERIOR} boundary conditions when
it comes to filling ghost cells in that ghost cell values are simply copied in from the valid
region of another grid.  In fact, one can think of {\tt PERIODIC} as just
a special type of {\tt INTERIOR} boundary condition.
For the other boundary conditions types, the user can write custom boundary 
conditions routines to fill ghost cells, which can involve setting ghost cell values 
directly, or using interior points and/or physical boundary conditions in some stencil operation.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{figure}[tb]
\centering
\includegraphics[width=4in]{./F_AdvancedTopics/bc_example2}
\caption{\label{fig:bc_example2}Two-dimensional example with 16 - 4$^2$grids with
{\tt PERIODIC} and {\tt NO\_SLIP\_WALL} boundary conditions.
The numbers refer to the grid number.}
\end{figure}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\item Now, consider an example with refined grids.  Figure \ref{fig:bc_example3}
contains three grids at the next level of refinement.  In this case, for grid 1,
all of the boundary condition types are {\tt INTERIOR}, even though the neighboring
valid region data is at a coarser level of refinement.  For grid 2, the low-y
boundary condition is {\tt NO\_SLIP\_WALL}, and the other three walls are {\tt INTERIOR}.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{figure}[tb]
\centering
\includegraphics[width=4in]{./F_AdvancedTopics/bc_example3}
\caption{\label{fig:bc_example3}Two-dimensional example with 3 grids at a finer
resolution than the base grid.}
\end{figure}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\end{itemize}

\subsection{Implementation}
Typically, we read in integer values from the inputs file for {\tt bc\_x\_lo}, 
{\tt bc\_x\_hi}, {\tt bc\_y\_lo}, etc., that correspond to the physical boundary condition types.
We then build a {\tt bc\_tower} object which is an array of {\tt bc\_level} objects, one for
each level of refinement.  The {\tt bc\_level} contains several integer array data structures,
as can be seen in {\tt BoxLib/Src/F\_BaseLib/define\_bc\_tower.f90}:
\begin{lstlisting}[backgroundcolor=\color{light-green}]
type bc_level

   ! 1st index is the grid number (grid "0" corresponds to the prob domain)
   ! 2nd index is the direction (1=x, 2=y, 3=z)
   ! 3rd index is the side (1=lo, 2=hi)
   ! 4th index is the variable (only assuming 1 variable here)
   integer, pointer :: phys_bc_level_array(:,:,:) => Null()
   integer, pointer ::  adv_bc_level_array(:,:,:,:) => Null()
   integer, pointer ::  ell_bc_level_array(:,:,:,:) => Null()

end type bc_level
\end{lstlisting}
Each level has a {\tt phys\_bc\_level\_array(0:ngrids,dim,2)} array, where {\tt ngrids} is the number of
grids on that level, {\tt dim} is the dimensionality of the simulation, and the third index refers to
the lower or upper edge of the grid in that coordinate direction.  This stores the {\it physical description}
of the boundary type ({\tt INLET}, {\tt OUTLET}, etc.), which is independent of the variables that live on
the grid.  The {\tt phys\_bc\_level\_array(0,:,:)} refers to the entire domain.  If an edge of a grid is not
a physical boundary, then it is set to a default value, typically {\tt INTERIOR}.  These boundary condition
types are used to interpret the actual method to fill the ghost cells for each variable, as described
in {\tt adv\_bc\_level\_array} and {\tt ell\_bc\_level\_array}.

Whereas {\tt phys\_bc\_level\_array} provides a physical description of the type of boundary, the array
{\tt adv\_bc\_level\_array} describes the action to be taken (e.g. reflect, extrapolate, etc.) for each 
variable when filling physical ghost cells on domain boundaries.  The prefix ``{\tt adv\_}'' is somewhat
of a misnomer, as this data structure was originally intended to tell advection (or hyperbolic) solvers
how to fill ghost cells, but now is generally used to fill physical domain boundary ghost cells in any
instance where the user needs to set them.
The form of this array is {\tt adv\_bc\_level\_array(0:ngrids,dim,2,nvar)}
where the additional component, nvar, allows for different state variable that lives on a grid to have 
different boundary condition actions associated with it.  For example, you could have {\tt nvar=1}
correspond to the x-velocity, {\tt nvar=2} correspond to density, and {\tt nvar=3} correspond to pressure.
In the {\tt BoxLib/Tutorials/HeatEquation\_EX2\_F/} tutorial, there is only one variable, $\phi$, so
obviously {\tt nvar=1} shall correspond to $\phi$.  When we build the {\tt adv\_bc\_level\_array},
we first set all values to {\tt INTERIOR}, and then overwrite any physical domain boundary condition types,
as given in {\tt phys\_bc\_level\_array}.  The {\tt adv\_bc\_level\_array} types supported by default are
(as listed in {\tt BoxLib/Src/F\_BaseLib/bc.f90}):
\begin{lstlisting}[backgroundcolor=\color{light-green}]
integer, parameter, public :: INTERIOR     =  0

integer, parameter, public :: REFLECT_ODD  =  20
integer, parameter, public :: REFLECT_EVEN =  21
integer, parameter, public :: FOEXTRAP     =  22
integer, parameter, public :: EXT_DIR      =  23
integer, parameter, public :: HOEXTRAP     =  24
\end{lstlisting}

To manually fill ghost cells, we call {\tt multifab\_physbc}, passing in the state multifab
along with the {\tt adv\_bc\_level\_array}.  The subroutines {\tt physbc\_1d/2d/3d} in
{\tt BoxLib/Src/F\_BaseLib/multifab\_physbc.f90}, indicate how to fill ghost cells.  For example,
\begin{lstlisting}[backgroundcolor=\color{light-green}]
  subroutine multifab_physbc(s,start_scomp,start_bccomp,ncomp, &
                             the_bc_level,time_in,dx_in, &
                             prob_lo_in,prob_hi_in)

    integer        , intent(in   )           :: start_scomp,start_bccomp
    integer        , intent(in   )           :: ncomp
    type(multifab) , intent(inout)           :: s
    type(bc_level) , intent(in   )           :: the_bc_level
    real(kind=dp_t), intent(in   ), optional :: time_in,dx_in(:)
    real(kind=dp_t), intent(in   ), optional :: prob_lo_in(:),prob_hi_in(:)

    ! Local
    integer                  :: lo(get_dim(s)),hi(get_dim(s))
    integer                  :: i,ng,dm,scomp,bccomp
    real(kind=dp_t)          :: time,dx(get_dim(s))
    real(kind=dp_t)          :: prob_lo(get_dim(s)),prob_hi(get_dim(s))
    real(kind=dp_t), pointer :: sp(:,:,:,:)
    
    ! set optional arguments
    time    = 0.d0
    dx      = 0.d0
    prob_lo = 0.d0
    prob_hi = 0.d0
    if (present(time_in))       time = time_in
    if (present(dx_in))           dx = dx_in
    if (present(prob_lo_in)) prob_lo = prob_lo_in
    if (present(prob_hi_in)) prob_hi = prob_hi_in

    ng = nghost(s)
    dm = get_dim(s)
    
    do i=1,nfabs(s)
       sp => dataptr(s,i)
       lo = lwb(get_box(s,i))
       hi = upb(get_box(s,i))
       select case (dm)
       case (2)
          do scomp=start_scomp,start_scomp+ncomp-1
             bccomp = start_bccomp + scomp - start_scomp
             call physbc_2d(sp(:,:,1,scomp), lo, hi, ng, &
                          the_bc_level%adv_bc_level_array(i,:,:,bccomp), &
                          time, dx, prob_lo, prob_hi)
          end do
...

  subroutine physbc_2d(s,lo,hi,ng,bc,time,dx,prob_lo,prob_hi)

    use bl_constants_module
    use bc_module

    integer        , intent(in   ) :: lo(:),hi(:),ng
    real(kind=dp_t), intent(inout) :: s(lo(1)-ng:,lo(2)-ng:)
    integer        , intent(in   ) :: bc(:,:)
    real(kind=dp_t), intent(in   ) :: time,dx(:),prob_lo(:),prob_hi(:)

    ! Local variables
    integer :: i,j

    !!!!!!!!!!!!!
    ! LO-X SIDE
    !!!!!!!!!!!!!

    if (bc(1,1) .eq. EXT_DIR) then
       ! set all ghost cell values to a prescribed dirichlet
       ! value; in this example, we have chosen 1
       do j = lo(2)-ng, hi(2)+ng
          s(lo(1)-ng:lo(1)-1,j) = 1.d0
       end do
    else if (bc(1,1) .eq. FOEXTRAP) then
       ! set all ghost cell values to first interior value
       do j = lo(2)-ng, hi(2)+ng
          s(lo(1)-ng:lo(1)-1,j) = s(lo(1),j)
       end do
...
\end{lstlisting}

Note that the optional arguments allow for the use of space and/or time-dependent
boundary conditions.

{\tt ell\_bc\_level\_array} is the analog to {\tt adv\_bc\_level\_array} for the linear 
solvers in \BoxLib.  These will be described in Section \ref{Sec:Linear Solvers}.

\section{Multiple Levels of Refinement}\label{Sec:Refinement}
In the {\tt BoxLib/Tutorials/HeatEquation\_EX3\_F/} tutorial, we have expanded our example
to the cases of multiple levels of refinement, with the grids fixed in space.  
In this example we advance all the grids
with the same time step, and perform synchronization operations between levels.\\

The big change for this tutorial is that we use a "multilevel layout" {\tt ml\_layout} 
rather than a {\tt layout}, and also {\tt multifab phi} and {\tt dx} are now {\tt nlevs} sized arrays.
After initializing or updating $\phi$, we must fill all ghost cell and synchronize the solution between
levels.  After we make the fluxes, we must synchronize the fluxes to maintain conservation.\\

There are three key subroutines for filling ghost cells and synchronizing data in multilevel applications.
Each of these involves a coarse level and a fine level:
\begin{itemize}

\item {\tt ml\_cc\_restriction} sets coarse cell-centered values equal to the average of the fine
  cells covering it.

\item {\tt ml\_edge\_restriction} sets coarse edge-centered values (such as fluxes) equal to the average
  of the fine edges covering it.

\item {\tt multifab\_fill\_ghost\_cells} fills fine ghost cells using interpolation from the underlying coarse
  data.  Note that this operation does not affect ghost cells that would be filled by {\tt multifab\_fill\_boundary}
  or {\tt multifab\_physbc}.

\end{itemize}

\section{Adaptive Mesh Refinement}\label{Sec:AMR}
Now fully implemented in {\tt BoxLib/Tutorials/HeatEquation\_EX4\_F/}.  The basic idea is
to ``tag'' the cells you with to refine in {\tt BoxLib/Src/F\_BaseLim\b/tag\_boxes.f90}.  To write
your own customized tagging criteria, copy {\tt tag\_boxes.f90} into your local directory and modify
it, since this copy will take precedence over the version in the \BoxLib~source.

There are several new
parameters that can be set via an inputs file:
\begin{itemize}
\item {\tt amr\_buf\_width}: radius (in cells) of tagged cells in addition to those already tagged due to the criteria in {\tt tag\_boxes.f90}.
\item {\tt cluster\_minwidth}: any newly created grids must be at least this many cells in each direction.
\item {\tt cluster\_blocking\_factor}: any newly created grids must have an integer multiple of this many cells in each direction.
\item {\tt cluster\_min\_eff}: This is a real number between 0 and 1 that controls how tightly the newly created grids match the tagged cells.  As this value approaches 1, you will have more, smaller grids.  Another way to think of this is that during the grid creation process, at least 100$\times${\tt cluster\_min\_eff} percent of the cells in each grid at which the grid creation occurs must be tagged cells.
\item {\tt regrid\_int}: frequency, in time steps, on when to regrid the simulation.
\end{itemize}
It is worth playing around with the inputs files to see what effect these parameters have on the grid structure.

\section{Linear Solvers}\label{Sec:Linear Solvers}
The tutorial code {\tt BoxLib/Tutorials/HeatEquation\_EX5\_F/} contains an implicit version of the heat equation 
example.  Fortran90 \BoxLib contains a ``cell-centered'' multigrid solver that solves linear systems of the form:
\begin{equation}
(\alpha\mathcal{I} - \nabla\cdot\beta\nabla)\phi = \text{RHS},
\end{equation}
where $\alpha, \phi$, and RHS are cell-centered \MultiFab~s, and $\beta$ is an array of \MultiFab~s that 
are nodal in exactly one direction (i.e., one face-centered \MultiFab for each spatial direction).
The Laplacian-like term in the left-hand-side can be discretized in several ways.  The simplest discretization
option is similar to a 5-point (7-point in 3D) Laplacian:
\begin{eqnarray}
\nabla\cdot\beta\nabla\phi_{ij} &=&
\frac{1}{\Delta x} \left[\beta_{i+\myhalf,j}\frac{\phi_{i+1,j} - \phi_{ij}}{\Delta x} - \beta_{i-\myhalf,j}\frac{\phi_{ij} - \phi_{i-1,j}}{\Delta x}\right]\nonumber\\
&&+ \frac{1}{\Delta y} \left[\beta_{i,j+\myhalf}\frac{\phi_{i,j+1} - \phi_{ij}}{\Delta y} - \beta_{i,j-\myhalf}\frac{\phi_{ij} - \phi_{i,j-1}}{\Delta y}\right].
\end{eqnarray}
A fully implicit discretization of the heat equation,
\begin{equation}
\frac{\phi^{n+1} - \phi^n}{\Delta t} = \left[\nabla\cdot(\nabla\phi)\right]^{n+1},
\end{equation}
is equivalent to
\begin{equation}
(\mathcal{I} - \Delta t\nabla\cdot\nabla)\phi^{n+1} = \phi^n.
\end{equation}
Thus, we will set $\alpha=1$, each $\beta=\Delta t$, and RHS = $\phi^n$.

\section{Subcycling in Time}\label{Sec:Subcycling}
In {\tt BoxLib/Tutorials/HeatEquation\_EX6\_F/} we have expanded the explicit version 
of the heat equation example in {\tt BoxLib/Tutorials/HeatEquation\_EX4\_F/} 
to include an example of subcycling in time.  In the previous examples, which did not
use subcycling in time, each level was advanced with the same time step, which was determined
by imposing the CFL criterion at the finest level.  In the example in 
{\tt BoxLib/Tutorials/HeatEquation\_EX6\_F/}, we use both temporal and spatial refinement;
$\Delta t$ decreases as $\Delta x$ decreases so that each level is running at a different
time step.  This strategy requires fewer steps to be taken at all but the finest levels
relative to the non-subcycling algorithm, but requires a more sophisticated synchronization algorithm 
between levels.  Overall, the use of subycling for explicit methods usually reduces runtime despite the 
synchronization overhead.

With subycling in time, the advance of each level is called recursively from coarsest to finest.
Inter-level synchronization must be ensured after each global time step and
additionally after each sub-step of the algorithm. The time step for each level is determined before the
solution at this level is advanced. The simplification of the original method implemented in this example consists
in performing a fixed number of time steps on the finer meshes for every time step on the lower level mesh.
The time step size of sub-steps at the highest level is equal to the time step used in previous examples 
$\Delta t_{min}$. However, the advantage of subcycling is that the time step for any lower level grid can be
$num\_substeps$ longer and in particular the global (level~$\ell=1$) time step becomes:
\begin{equation}
	\Delta t_{global} = \Delta t_{min}  \cdot {(num\_substeps)}^{nlevs-1},
\end{equation}
where $num\_substeps$ is dependent on the problem type. For the parabolic problem of the heat equation
considered here it is equal to $4$, for an advection equation it would equal $2$. These values guarantee
that a given CFL condition is met at each level for each problem type.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{figure}[tb]
\centering
\includegraphics{./F_AdvancedTopics/subcycling_algorithm}
\caption{\label{fig:subcycling_algorithm} Subcycling algorithm with 3 levels of refinement. 
        $num\_substeps=2$ is assumed here for clarity. }
\end{figure}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

During the single global time step, the algorithm performs ${(num\_substeps)}^{\ell-1}$ steps at each level $\ell$
according to the predefined sequence presented in Figure~\ref{fig:subcycling_algorithm}. The main rule
is that coarser levels are always updated before the finer ones. For each level the algorithm
performs the following:
\begin{itemize}
\item First, data from cells that are covered by ghost cells of a finer mesh are stored; these are later used
by the ghost cells at the higher level.
\item Next, fluxes that will be used for the solution update are computed.
\item Before proceeding to the next step, flux values from level $\ell$ are stored for the subsequent flux-fix
procedure on level $\ell$. This procedure applies to cells at outer inter-level interfaces.
\item Finally, the solution at current level is advanced by the respective time step.
\end{itemize}
If the current level is the highest level, the described procedure is executed $(num\_substeps-1)$ more times,
otherwise it is executed for the next higher level. If any of the levels has been advanced $num\_substeps$ times,
restriction of the solution is performed and the flux fix procedure is called. Then the algorithm
described above is called for the lower level. The whole algorithm proceeds until the flux fix procedure is
executed for the level $\ell=1$.

The so-called \textit{hanging nodes} that arise at interfaces between two regions of different level of
refinement require special treatment during the flux computation and time update when subcycling is used.
The restriction is performed for each refined cell (overlaid by finer cells) that abuts an unrefined cell
from the same level after each $num\_substeps$ time steps on the fine mesh. Both the refined and the
uncovered coarse cells, from both sides of the boundary, have previously been updated to the states
$\tilde \phi^{n+1}_{parent}$ and $\tilde \phi^{n+1}_{unrefined}$, respectively, using a common coarse flux.
This flux is likely to be different and less accurate than the mean of the fine grid fluxes which were
computed across the boundary between the fine grid interior and ghost cells.
The restriction updates the state in a refined cell to
$\phi^{n+1}_{parent}$, which is equivalent to replacing the coarse flux with the mean of finer ones; obviously,
this leads to lack of conservation. This deficiency is corrected by updating the state of the unrefined
cell by the difference between the coarse and mean over the sub-steps of the restricted fine fluxes. The so-called
\textit{flux-fix} (or \textit{reflux}) is evaluated as follows:
\begin{equation}
\label{eq:fluxfix}
F_{fix} = - \tilde F_{unrefined}
+ \frac{1}{num\_substeps}  \sum_{s=1}^{num\_substeps} \left( F^{s}_{restricted} \right) ,
\end{equation}
where $\tilde F_{unrefined} = - \tilde F_{parent}$.
The above applies to each face (edge in 2D) at a fine-coarse boundary. Note, that for other faces $F_{fix} = 0$.
The solution at each unrefined cell that abuts a refined cell from the same level after each
$num\_substeps$ time steps on the fine mesh is then updated in the same manner when the regular time advancement is
performed:
\begin{equation}
\label{eq:apply_fluxfix}
\phi^{n+1}_{i,j}=\tilde \phi^{n+1}_{i,j}
+ \frac{\Delta t }{\Delta x } \cdot \left( F^{fix}_{i-\frac{1}{2},j} - F^{fix}_{i+\frac{1}{2},j} \right)
+ \frac{\Delta t }{\Delta x } \cdot \left( F^{fix}_{i,j-\frac{1}{2}} - F^{fix}_{i,j+\frac{1}{2}} \right).
\end{equation}

